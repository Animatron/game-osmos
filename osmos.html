<!DOCTYPE html>
<html>
	<head>
		<title>Osmos - Animatron HTML5 Player Demo</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<script src="../player/vendor/matrix.js" type="text/javascript"></script>
		<script src="../player/anm.player.js" type="text/javascript"></script>
		<script src="../player/anm.builder.js" type="text/javascript"></script>
		<script src="../player/animatron_import.js" type="text/javascript"></script>

		<script type="text/javascript">
			var b = Builder._$, B = Builder, C = anm.C;
			
			// canvas
			var width = 640;
			var height = 480;
			var scene1 = b();
			var background = b();
            var foreground = b();
			
			var time = 0;
			
			var dot = new Array(1);
			var allMass;
			
			function toHex(n) {
				return ((n < 16) ? '0' : '') + n.toString(16);
			}
			
			function hsvToHex(h, s, v) {
				var r, g, b;

   				var i = Math.floor(h * 6);
    			var f = h * 6 - i;
    			var p = v * (1 - s);
    			var q = v * (1 - f * s);
    			var t = v * (1 - (1 - f) * s);

    			switch(i % 6){
        			case 0: r = v, g = t, b = p; break;
        			case 1: r = q, g = v, b = p; break;
        			case 2: r = p, g = v, b = t; break;
        			case 3: r = p, g = q, b = v; break;
        			case 4: r = t, g = p, b = v; break;
        			case 5: r = v, g = p, b = q; break;
    			}
				
				return '#' + toHex(Math.floor(r*255)) + toHex(Math.floor(g*255)) + toHex(Math.floor(b*255));
			}
			
			var mainModifier = function(t) {
				time = t;
				
				// add bubbles
				if (Math.random() < .15)			
					background.add(bubble());
			}
			
			var dotModifier = function(t, i) {
				var vx = dot[i].data().vx;
				var vy = dot[i].data().vy;
				this.x = dot[i].data().x + vx;
				this.y = dot[i].data().y + vy;
				this.sx = dot[i].data().r;
				this.sy = dot[i].data().r;
				
				// reflect
				if (this.x < this.sx) {
					this.x = 2*this.sx - this.x;
					vx *= -1;
				} else if (this.x > width - this.sx) {
					this.x = 2*(width - this.sx) - this.x;
					vx *= -1;
				}
				if (this.y < this.sy) {
					this.y = 2*this.sy - this.y;
					vy *= -1;
				} else if (this.y > height - this.sy) {
					this.y = 2*(height - this.sy) - this.y;
					vy *= -1;
				}
				
				// check for collision
				for (var j=i+1; j<dot.length; j++) {
					var d = Math.sqrt(Math.pow(dot[j].data().x-this.x, 2) + Math.pow(dot[j].data().y-this.y, 2));
					var r1, r2;
					if (this.sx >= dot[j].data().r) {
						r1 = this.sx;
						r2 = dot[j].data().r;
					} else {
						r1 = dot[j].data().r;
						r2 = this.sx;
					}
					if (d < r1 + r2) {
						var o = dot[j].data();
						var v;
						if (d >= r1)
							// intersection doesn't contain centers
							v = Math.PI * Math.pow(r1+r2-d, 2) * (d*d + 2*d*r2 - 3*r2*r2 + 2*d*r1 + 6*r1*r2 - 3*r1*r1) / (12*d);
						else if (d > r1-r2 && d < r1)
							// intersection contains centers
							v = 4*r2*r2*r2/3 - Math.PI * Math.pow(r1-r2-d, 2) * (d*d + 2*d*r1 - 3*r2*r2 - 2*d*r2 - 6*r1*r2 - 3*r1*r1) / (12*d*d*d);
						else
							// instersection contains whole sphere
							v = 4*r2*r2*r2/3;
						console.log(r1+" <- "+d+" -> "+r2+"  ==>  "+(4*r1*r1*r1/3)+" <- "+v+" <- "+(4*r2*r2*r2/3));
						if (this.sx >= o.r) {
							this.sx = Math.pow(3*(4*r1*r1*r1/3 + v)/4, 1/3);
							// TODO: removal case
							dot[j].data({'r': Math.pow(3*(4*r2*r2*r2/3 - v)/4, 1/3), 'x':o.x, 'y':o.y, 'vx': o.vx, 'vy': o.vy});
						} else {
							this.sx = Math.pow(3*(4*r2*r2*r2/3 - v)/4, 1/3);
							// TODO: removal case
							dot[j].data({'r': Math.pow(3*(4*r1*r1*r1/3 + v)/4, 1/3), 'x':o.x, 'y':o.y, 'vx': o.vx, 'vy': o.vy});
						}
					}
				}
				
				dot[i].data({'r': this.sx, 'x':this.x, 'y':this.y, 'vx': vx, 'vy': vy});
			}
			
			var bubbleModifier = function(t) {
				if (!b(this.$).data().init) {
					var d = b(this.$).data();
					this.x = Math.random()*width;
					this.y = height + b(this.$).data().r;
					b(this.$).data({'init': true, 'r': d.r, 'v': d.v, 'm': d.m});
				} else {
					var v = b(this.$).data().v;
					this.x += v/2*Math.sin(t + v);
					this.y -= v;
					this.sx = b(this.$).data().r;
					this.sy = b(this.$).data().r;
					var a = (this.y - b(this.$).data().m) / (height - b(this.$).data().m);
					if (a > 0)
						b(this.$).stroke('rgba(255, 255, 255, '+a/2+')', 1/3);
					else
						background.remove(this);
				}
			}
			
			function main() {
				return b().paint(function(ctx) {
					var h;
					if (dot[0])
						h = Math.min(4*Math.pow(dot[0].data().r, 3)/3/allMass, 1);
					else
						h = 0;
					var grad = ctx.createLinearGradient(0, 0, 0, height);
					grad.addColorStop(0, hsvToHex(.55, h, .67+h/3));
					grad.addColorStop(1, hsvToHex(.55, h, h/3));
					ctx.beginPath();
					ctx.rect(0, 0, width, height);
					ctx.fillStyle = grad;
					ctx.fill();
					ctx.closePath();
					
					// draw background
					ctx.globalAlpha = 1;
					ctx.drawImage(document.getElementById('bCanvas'), 0, 0);
					
					// draw foreground
					ctx.globalAlpha = .83 + Math.cos(time)/6;
					ctx.drawImage(document.getElementById('fCanvas'), 0, 0);
					ctx.globalAlpha = 1;
				}).modify(mainModifier);
			}
			
			function make(i) {
				return b().paint(function(ctx) {
					var h;
					if (dot[0])
						h = Math.min(dot[i].data().r/dot[0].data().r, 1);
					else
						h = 1;
					
					for (var n=0; n<4; n++) {
						ctx.beginPath();
						ctx.arc(-n/10, -n/10, 1-n/4, 0, 2*Math.PI, false);
						ctx.fillStyle = hsvToHex(h, 1, .7+.1*n);
        				ctx.fill();
						ctx.closePath();
					}
				}).modify(dotModifier, i);
			}
			
			function bubble() {
				var r = Math.random()*4+2;
				var v = Math.random()*4+2;
				var m = Math.random()*320+r;
				return b().circle([ 0, 0 ], 1).fill('rgba(255, 255, 255, 0)')
				.data({'init': false, 'r': r, 'v': v, 'm': m})
				.modify(bubbleModifier);
			}
			
            function start() {
				scene1.add(main());
				
				// doesn't work
				//scene1.add(b().path('M177.69 0 c-10.32 9 -6.062 -29.632 -10.14 -51.742 -10.14 S84.535 -6.061 74.206 0 c10.329 6.061 29.632 10.139 51.742 10.139 C148.058 10.14 167.361 6.062 177.69 0 z'));
				
				// test
				dot[0] = make(0).data({'r': 20, 'x':20, 'y':20, 'vx': 0, 'vy': 0});
				foreground.add(dot[0]);
				allMass = 4*Math.pow(dot[0].data().r, 3)/3;
				
				scene1.on(C.X_MCLICK, function(evt) {
					// find masses
					var e = .1;
					var m = 4*Math.pow(dot[0].data().r, 3)/3;
					var m1 = (1-e) * m;
					var m2 = e*m;
					console.log("split: "+m+" -> "+m1+" + "+m2);
					var r1 = Math.pow(3*m1/4, 1/3);
					var r2 = Math.pow(3*m2/4, 1/3);
					var vx = dot[0].data().vx;
					var vy = dot[0].data().vy;
					
					// determine angle
					var s = 1;
					var x = dot[0].data().x;
					var y = dot[0].data().y;
					var a = Math.atan2(evt.pos[1] - y, evt.pos[0] - x);
					var vx2 = s*Math.cos(a) + vx;
					var vy2 = s*Math.sin(a) + vy;
					
					// find new velocities
					// m1*vx1 + m2*vx2 = m*vx
					
					var vx1 = (m*vx - m2*vx2)/m1;
					var vy1 = (m*vy - m2*vy2)/m1;
					
					// modify object
					dot[0].data({'r': r1, 'x':x, 'y':y, 'vx': vx1, 'vy': vy1});
					var l = dot.length;
					dot.push(make(l).data({'r': r2, 'x':x+(r1+r2)*Math.cos(a), 'y':y+(r1+r2)*Math.sin(a), 'vx': vx2, 'vy': vy2}));
					foreground.add(dot[l]);
				});
				
				createPlayer('canvas', {'mode': C.M_DYNAMIC}).load(scene1).play();
				createPlayer('bCanvas', {'mode': C.M_DYNAMIC, 'cnvs': {'bgfill': 'rgba(255, 255, 255, 0)'}}).load(background).play();
				createPlayer('fCanvas', {'mode': C.M_DYNAMIC, 'cnvs': {'bgfill': 'rgba(255, 255, 255, 0)'}}).load(foreground).play();
    
            }
        </script>
      </head>

	<body onload="start();">
		<h1>Osmos - Animatron HTML5 Player Demo</h1>

		<!-- canvases -->
		<canvas id="canvas" width="640" height="480"></canvas>
        <canvas id="bCanvas" width="640" height="480" style="display:none;"></canvas>
        <canvas id="fCanvas" width="640" height="480" style="display:none;"></canvas>

	</body>

</html>